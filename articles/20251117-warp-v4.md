---
title: "warp v0.4 ã§ TLS ã‚’åˆ©ç”¨ã™ã‚‹"
emoji: "ğŸŒ€"
type: "tech"
topics: ["rust", "warp"]
published: true
---

warp v0.4 ã§ã¯ã€ã“ã‚Œã¾ã§ä¾¿åˆ©ã«ä½¿ãˆã¦ã„ãŸ `warp::serve` ã‚„ `tls` ãƒ•ã‚£ãƒ¼ãƒãƒ£ãŒå‰Šé™¤ã•ã‚Œã€ã‚¢ãƒ—ãƒªéƒ¨åˆ†ï¼ˆFilterï¼‰ã¨ã‚µãƒ¼ãƒãƒ¼éƒ¨åˆ†ï¼ˆhyper / tokioï¼‰ã‚’è‡ªåˆ†ã§çµ„ã¿åˆã‚ã›ã‚‹æ§‹æˆã«å¤‰ã‚ã‚Šã¾ã—ãŸã€‚
ãã®ãŸã‚ã€Œwarp ã§ TLS å¯¾å¿œã‚µãƒ¼ãƒãƒ¼ã‚’ä½œã‚ŠãŸã„ã€ã€ŒHTTP/2 ã«å¯¾å¿œã—ãŸã„ã€ã¨ã„ã£ãŸéœ€è¦ã«å¯¾ã—ã¦ã€å¾“æ¥ã‚ˆã‚Šã‚‚ ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä»•çµ„ã¿ã‚’ç†è§£ã—ãŸä¸Šã§æ§‹æˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

æœ¬è¨˜äº‹ã§ã¯ã€ã¾ãšæœ€å°æ§‹æˆã¨ã—ã¦ TLS ãªã—ã® HTTP/1 ã‚µãƒ¼ãƒãƒ¼ã‚’ warp v0.4 ã§å‹•ã‹ã™ã‚³ãƒ¼ãƒ‰ã‚’ç¤ºã—ã€Filter â†’ Service â†’ hyper ã¨ã„ã†æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ã‚’æ•´ç†ã—ã¾ã™ã€‚ã“ã“ãŒç†è§£ã§ãã‚Œã°ã€TLS å¯¾å¿œã‚„ HTTP/2 å¯¾å¿œã¯ã‚½ã‚±ãƒƒãƒˆå‘¨ã‚Šã‚’ç½®ãæ›ãˆã‚‹ã ã‘ã§å®Ÿç¾ã§ãã¾ã™ã€‚

ã€Œwarp v0.3 ã®æ›¸ãæ–¹ã«ã¯æ…£ã‚Œã¦ã„ã‚‹ã‘ã‚Œã©ã€v0.4 ã§ä½•ãŒå¤‰ã‚ã£ãŸã®ã‹ã‚ˆãåˆ†ã‹ã‚‰ãªã„ã€ã¨ã„ã†æ–¹ã®ãŸã‚ã« v0.3 ã®ã‚³ãƒ¼ãƒ‰ã‚‚ä½µè¨˜ã—ã¦ã‚ã‚Šã¾ã™ã€‚

warp v0.4 ã‚’å­¦ã¶ã“ã¨ã¯ã€Axum ã®å†…éƒ¨æ§‹é€ ï¼ˆhyperÃ—towerï¼‰ã®ç†è§£ã«ç›´çµã—ã¾ã™ã€‚ç§è‡ªèº«ã¯ã€ext-php-rs ã‚’é€šã˜ã¦ PHP ã‹ã‚‰åˆ©ç”¨å¯èƒ½ãªè»½é‡ HTTP ã‚µãƒ¼ãƒãƒ¼ã‚’æ§‹ç¯‰ã—ãŸã„ã¨ã„ã†å‹•æ©ŸãŒã‚ã‚Šã€warp v0.4 ã¯ãã®ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼æ§‹æˆã‚’ç†è§£ã™ã‚‹ãŸã‚ã®æ•™æã«ãªã‚Šã¾ã—ãŸã€‚


TLS ãªã—ã® HTTP/1 ã‚µãƒ¼ãƒãƒ¼
---------------------------

ã‹ã‚“ãŸã‚“ãªå‹•ä½œç¢ºèªã®ãŸã‚ã€TLS ãªã—ã® HTTP/1 ã‚µãƒ¼ãƒãƒ¼ã®ã‚³ãƒ¼ãƒ‰ã®ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚


### v0.3

warp v0.3 ã§ã®æ›¸ãæ–¹ã§ã™ã€‚

```toml:Cargo.toml
[package]
name = "warp-v0.3-project"
version = "0.1.0"
edition = "2021"

[dependencies]
hyper = { version = "1", features = ["full"] }
tokio = { version = "1", features = ["full"] }
warp = { version = "0.3", default-features = false }
```

```rust:main.rs
#![deny(warnings)]
use warp::Filter;

#[tokio::main]
async fn main() {
    let base = warp::path::end().map(|| "Hello, World at root!");
    let route =
        warp::path!(String).map(|name| format!("{}", name));

    let routes = warp::get().and(
        base
        .or(route)
    );

    warp::serve(routes).run(([127, 0, 0, 1], 3030)).await;
}
```



### v0.4

æ¬¡ã¯ warp v0.4 ã®ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚å¾Œã§ TLS ã«å¯¾å¿œã•ã›ã‚‹ãŸã‚ã«è‡ªåˆ†ã§ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½œæˆã™ã‚‹æ–¹æ³•ã§ã™ã€‚TLS ã«å¯¾å¿œã•ã›ã‚‹å¿…è¦ãŒãªã„ãªã‚‰ã€å‰è¿°ã® v0.3 ã®ã‚³ãƒ¼ãƒ‰ãŒä½¿ãˆã¾ã™ã€‚

```toml:Cargo.toml
[package]
name = "warp-v0.4-project"
version = "0.1.0"
edition = "2021"

[dependencies]
hyper = { version = "1", features = ["full"] }
tokio = { version = "1", features = ["full"] }
warp = { version = "0.4", default-features = false }
```

```rust:main.rs
use std::net::SocketAddr;
use hyper::server::conn::http1;
use hyper_util::rt::TokioIo;
use hyper_util::service::TowerToHyperService;
use tokio::net::TcpListener;
use warp::Filter;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {

    let routes = warp::any().map(|| "Hello, World!".to_string());
    let tower_svc = warp::service(routes);
    let hyper_svc = TowerToHyperService::new(tower_svc);

    let addr: SocketAddr = ([127, 0, 0, 1], 3000).into();
    let listener = TcpListener::bind(addr).await?;
    println!("listening on http://{addr}");

    loop {
        let (stream, _peer) = listener.accept().await?;
        let io = TokioIo::new(stream);
        let svc = hyper_svc.clone();

        tokio::spawn(async move {
            if let Err(err) = http1::Builder::new()
                .serve_connection(io, svc)
                .await
            {
                eprintln!("error serving connection: {err}");
            }
        });
    }
}
```

æ¬¡ã®ã€ŒFilter â†’ Service â†’ hyper ç”¨ Serviceã€ã¨ã„ã†ä¸‰æ®µéšã®å¤‰æ›ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```rust
let routes = warp::any().map(|| "Hello, World!".to_string());
let tower_svc = warp::service(routes);
let hyper_svc = TowerToHyperService::new(tower_svc);
```

`warp::any()` ã¯ã©ã‚“ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆã«ã‚‚ãƒãƒƒãƒã™ã‚‹ Filter ã§ã™ã€‚GET ä»¥å¤–ã® HTTP ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¯¾ã—ã¦ã‚‚ 200 ã‚’è¿”ã—ã¾ã™ã€‚`map(...)` ã¯ãƒãƒƒãƒã—ãŸå ´åˆã«å®Ÿè¡Œã•ã‚Œã‚‹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’æŒ‡å®šã—ã¾ã™ã€‚
ä»Šå›ã®å ´åˆã€``Hello, World!` ã®æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®åˆ¶ç´„ã‚’è€ƒãˆãªãã¦ã™ã‚€ã‚ˆã†ã«ã€æˆ»ã‚Šå€¤ã¯ `&'static str` ã§ã¯ãªã `String` ã«ã—ã¦ã„ã¾ã™ã€‚

`warp::service(routes)` ã¯ `Filter` ã‹ã‚‰ `tower::Service` ã‚’ä½œã‚‹é–¢æ•°ã§ã™ã€‚`Service<Request> -> Response` ã¨ã„ã†ã€Œé–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã®ã‚ˆã†ãªã‚‚ã®ã«ä¾‹ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
`TowerToHyperService::new(tower_svc)` ã¯ hyper ãŒæ±‚ã‚ã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã®å½¢ã«ãƒ©ãƒƒãƒ—ã™ã‚‹ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã§ã™ã€‚warp/tower ã§æ›¸ã„ãŸã‚¢ãƒ—ãƒªã‚’ã€hyper ã®ã‚µãƒ¼ãƒãƒ¼ãŒãã®ã¾ã¾æ‰±ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®å¤‰æ›ã§ã™ã€‚


TLS ã«å¯¾å¿œ
----------

### v0.3


warp v0.3 ã®ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚`Cargo.toml` ã§ `tls` ãƒ•ã‚£ãƒ¼ãƒãƒ£ã‚’æœ‰åŠ¹ã«ã—ã¾ã™ã€‚

```toml:Cargo.toml
[package]
name = "warp-v0.3-tls"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1", features = ["full"] }
warp = { version = "0.3", features = ["default", "tls"]}
```

```rust:main.rs
#![deny(warnings)]

#[tokio::main]
async fn main() {
    use warp::Filter;

    let routes = warp::any().map(|| "Hello, World!");

    warp::serve(routes)
        .tls()
        .cert_path("localhost.pem")
        .key_path("localhost-key.pem")
        .run(([127, 0, 0, 1], 3030))
        .await;
}
```


### v0.4


```toml:Cargo.toml
[package]
name = "warp-v0.4-tls"
version = "0.1.0"
edition = "2021"

[dependencies]
hyper = { version = "1", features = ["full"] }
tokio = { version = "1", features = ["full"] }
hyper-util = { version = "0.1", features = ["full"] }
warp = { version = "0.4", default-features = false }

tokio-rustls = "0.26"
rustls = "0.23"
rustls-pemfile = "2"
```

```rust:main.rs
use std::{fs::File, io::BufReader, net::SocketAddr, sync::Arc};

use tokio::net::TcpListener;
use tokio_rustls::TlsAcceptor;
use warp::Filter;

use hyper_util::rt::{TokioExecutor, TokioIo};
use hyper_util::server::conn::auto;
use hyper_util::service::TowerToHyperService;

use rustls::ServerConfig;
use rustls::pki_types::{CertificateDer, PrivateKeyDer, PrivatePkcs8KeyDer};
use rustls_pemfile::{certs, pkcs8_private_keys};

type Error = Box<dyn std::error::Error + Send + Sync>;

fn load_tls_config() -> Result<Arc<ServerConfig>, Error> {
    let cert_file = &mut BufReader::new(File::open("localhost.pem")?);
    let key_file = &mut BufReader::new(File::open("localhost-key.pem")?);

    let cert_chain: Vec<CertificateDer<'static>> =
        certs(cert_file).collect::<Result<Vec<_>, _>>()?;

    let mut keys: Vec<PrivatePkcs8KeyDer<'static>> =
        pkcs8_private_keys(key_file).collect::<Result<Vec<_>, _>>()?;

    if keys.is_empty() {
        return Err("no private key found in certs/key.pem".into());
    }

    let key_der: PrivateKeyDer<'static> = PrivateKeyDer::from(keys.remove(0));

    let mut config = ServerConfig::builder()
        .with_no_client_auth()
        .with_single_cert(cert_chain, key_der)?;

    config.alpn_protocols = vec![
        b"h2".to_vec(),
        b"http/1.1".to_vec(),
    ];

    Ok(Arc::new(config))
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    // rustls::crypto::aws_lc_rs::default_provider().install_default();

    // â˜… Reply ã‚’ String ã«ã™ã‚‹
    let routes = warp::path::end().map(|| {
        "Hello from warp over TLS (HTTP/1 & HTTP/2 auto)!".to_string()
    });

    let warp_service = warp::service(routes);
    let hyper_service = TowerToHyperService::new(warp_service);

    let tls_config = load_tls_config()?;
    let tls_acceptor = TlsAcceptor::from(tls_config);

    let addr: SocketAddr = ([127, 0, 0, 1], 3000).into();
    let listener = TcpListener::bind(addr).await?;
    println!("Listening on https://{addr} (HTTP/1 & HTTP/2 via ALPN)");

    loop {
        let (tcp_stream, peer_addr) = listener.accept().await?;
        let svc = hyper_service.clone();
        let acceptor = tls_acceptor.clone();

        tokio::spawn(async move {
            println!("accepted connection from {peer_addr}");

            let tls_stream = match acceptor.accept(tcp_stream).await {
                Ok(s) => s,
                Err(e) => {
                    eprintln!("TLS accept error: {e}");
                    return;
                }
            };

            let io = TokioIo::new(tls_stream);

            if let Err(err) = auto::Builder::new(TokioExecutor::new())
                .serve_connection(io, svc)
                .await
            {
                eprintln!("server connection error: {err}");
            }
        });
    }
}
```

Rust ã® TLS ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã¯éå»ã«ãŠã„ã¦äº’æ›æ€§ã®ãªã„ä»•æ§˜å¤‰æ›´ãŒã‚ã£ãŸã®ã§ã€AI ã§ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã™ã‚‹å ´åˆã€TLS ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã«æ³¨æ„ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

HTTP/1/2 ã®ä¸¡æ–¹ã«å¯¾å¿œã•ã›ã‚‹ãŸã‚ã« `hyper_util` ã‚’ä½¿ã„ã¾ã™ã€‚`ServerConfig::builder` ã®è¨­å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã‚ã‚‹ `config.alpn_protocols` ã‚’é€šã—ã¦ ALPN (Application-Layer Protocol Negotiation) ã§ä½¿ã† HTTP ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æŒ‡å®šã—ã¾ã™ã€‚ã‚µãƒ¼ãƒãƒ¼ã®ãƒ«ãƒ¼ãƒ—ã®ãªã‹ã§ `hyper_util::server::conn::auto::Builder` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚

Axum ã§ TLS å¯¾å¿œã«ã™ã‚‹å ´åˆã«ã‚‚ `ServerConfig::builder` ã‚„ `auto::Builder` ã‚’è‡ªåˆ†ã§å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚